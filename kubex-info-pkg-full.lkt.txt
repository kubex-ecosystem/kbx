# LookAtni Code Snapshot
# -----------------------
# Data de geração: 2025-12-08T10:26:39.330Z
# Fonte: /projects/kubex/kbx-utils/info
# Hostname: dev
# Sistema: linux x64 (Debian GNU/Linux 12 (bookworm))
# Kernel: 6.1.0-41-amd64
# Usuário: user
# UID: 1002
# Shell: /usr/bin/zsh
# Total de arquivos: 11
# Tamanho bruto: 0.0 MB
# Gerado por: lookatni@v1.2.0 (via CLI Script)
# Comando usado: tsx generateMarkers.ts generate ./ ../kubex-info-pkg-full.lkt.txt
# Hash do snapshot: 5af7a75ff9cc299eb6b1...

/// application.go ///
// Package info provides functionality to read and parse the application manifest.
package info

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"strings"

	"github.com/google/uuid"
	"github.com/kubex-ecosystem/kbx/info/ctl"
	"github.com/kubex-ecosystem/kbx/info/descriptors"

	gl "github.com/kubex-ecosystem/logz"
)

var banners = []string{
	`
     |  /        |                 
     | /  |   |  __ \    _ \  \  / 
     . \  |   |  |   |   __/    <  
    _|\_\\__._| _.__/  \___| _/\_\ 
    %s%b - %s%s
`,
}

func GetDescriptions(descriptionArg []string, _ bool) map[string]string {
	var description, banner string

	if descriptionArg != nil {
		if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
			description = descriptionArg[0]
		} else {
			description = descriptionArg[1]
		}
	} else {
		description = ""
	}

	manifest, err := GetManifest()
	if err != nil {
		description += ""
	} else {
		if manifest.GetDescription() != "" {
			description += manifest.GetDescription()
		}
	}

	bannerRandLen := len(banners)
	bannerRandIndex := rand.Intn(bannerRandLen)
	banner = fmt.Sprintf(banners[bannerRandIndex], "\033[1;34m", manifest.GetName(), manifest.GetVersion(), "\033[0m")

	return map[string]string{"banner": banner, "description": description}
}

// manifestJSONFile is the name of the manifest JSON file
const manifestJSONFile = "manifest.json"

// Embeds do arquivo manifest.json gerado na build.
var manifestJSONData []byte

func init() {
	var err error
	manifestJSONData, err = descriptors.GetManifestJSONFiles().ReadFile(manifestJSONFile)
	if err != nil {
		gl.Log("error", fmt.Sprintf("Failed to read embedded manifest.json: %v", err))
		manifestJSONData = []byte{}
	}
}

// var application Manifest

type Reference struct {
	ID              uuid.UUID `json:"id"`
	Name            string    `json:"name"`
	ApplicationName string    `json:"application"`
	Bin             string    `json:"bin"`
	Version         string    `json:"version"`
}

type mmanifest struct {
	Manifest
	Name            string   `json:"name"`
	ApplicationName string   `json:"application"`
	Bin             string   `json:"bin"`
	Version         string   `json:"version"`
	Repository      string   `json:"repository"`
	Aliases         []string `json:"aliases,omitempty"`
	Homepage        string   `json:"homepage,omitempty"`
	Description     string   `json:"description,omitempty"`
	Main            string   `json:"main,omitempty"`
	Author          string   `json:"author,omitempty"`
	License         string   `json:"license,omitempty"`
	Keywords        []string `json:"keywords,omitempty"`
	Platforms       []string `json:"platforms,omitempty"`
	LogLevel        string   `json:"log_level,omitempty"`
	Debug           bool     `json:"debug,omitempty"`
	ShowTrace       bool     `json:"show_trace,omitempty"`
	Private         bool     `json:"private,omitempty"`
}

func (m *mmanifest) GetName() string        { return m.Name }
func (m *mmanifest) GetVersion() string     { return m.Version }
func (m *mmanifest) GetAliases() []string   { return m.Aliases }
func (m *mmanifest) GetRepository() string  { return m.Repository }
func (m *mmanifest) GetHomepage() string    { return m.Homepage }
func (m *mmanifest) GetDescription() string { return m.Description }
func (m *mmanifest) GetMain() string        { return m.Main }
func (m *mmanifest) GetBin() string {
	if m.Bin == "" {
		m.Bin, _ = os.Executable()
	}
	return m.Bin
}
func (m *mmanifest) GetAuthor() string      { return m.Author }
func (m *mmanifest) GetLicense() string     { return m.License }
func (m *mmanifest) GetKeywords() []string  { return m.Keywords }
func (m *mmanifest) GetPlatforms() []string { return m.Platforms }
func (m *mmanifest) IsPrivate() bool        { return m.Private }

// lazy cache
var (
	cachedManifest Manifest
	cachedControl  *ctl.Control
)

// GetManifest lazy, sem init() com side-effects
func GetManifest() (Manifest, error) {
	if cachedManifest != nil {
		return cachedManifest, nil
	}

	if len(manifestJSONData) == 0 {
		return nil, gl.Errorf("manifest.json: embed is empty")
	}

	var m mmanifest
	if err := json.Unmarshal(manifestJSONData, &m); err != nil {
		return nil, gl.Errorf("manifest.json: %v", err)
	}
	cachedManifest = &m
	return &m, nil
}

// FS secOrder quiser permitir override por FS externo:
type FS interface {
	ReadFile(name string) ([]byte, error)
}

func LoadFromFS(fs FS) (Manifest, ctl.Control, error) {
	var m Manifest
	var c ctl.Control
	if b, err := fs.ReadFile("manifest.json"); err == nil {
		if err := json.Unmarshal(b, &m); err != nil {
			return nil, ctl.Control{}, gl.Errorf("manifest.json: %v", err)
		}
	} else {
		return nil, ctl.Control{}, gl.Errorf("manifest.json: %v", err)
	}
	if b, err := fs.ReadFile("control.json"); err == nil {
		if err := json.Unmarshal(b, &c); err != nil {
			return nil, ctl.Control{}, gl.Errorf("control.json: %v", err)
		}
	} else {
		return nil, ctl.Control{}, gl.Errorf("control.json: %v", err)
	}
	return m, c, nil
}

// func GetControl() (*Control, error) {
// 	if cachedControl != nil {
// 		return cachedControl, nil
// 	}
// 	var c Control
// 	if len(controlJSONData) == 0 {
// 		return nil, gl.Errorf("control.json: embed is empty")
// 	}
// 	if err := json.Unmarshal(controlJSONData, &c); err != nil {
// 		return nil, gl.Errorf("control.json: %v", err)
// 	}
// 	cachedControl = &c
// 	return &c, nil
// }

/// ctl/control.go ///
// Package ctl gerencia controle e configuração modular, com suporte a arquivos separados por módulo.
package ctl

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	kbx "github.com/kubex-ecosystem/kbx"
	gl "github.com/kubex-ecosystem/logz"
)

// Control representa a configuração de controle de um módulo.
type Control struct {
	*kbx.GlobalRef `json:"-"` // Usado internamente para nome do arquivo, nunca exportado
	SchemaVersion  int        `json:"schema_version"`
	IPC            IPC        `json:"ipc"`
	Bitreg         Bitreg     `json:"bitreg"`
	KV             KV         `json:"kv"`
	Seq            int        `json:"seq"`
	EpochNS        int64      `json:"epoch_ns"`
}

func (c *Control) GetName() string { return c.GlobalRef.Name }

// func (c *Control) GetVersion() string { return c.GlobalRef.Version }

// LoadControlByModule carrega o controle de um arquivo específico do módulo.
func LoadControlByModule(dir string, moduleName string) (*Control, error) {
	file := filepath.Join(dir, fmt.Sprintf("control_%s.json", moduleName))
	f, err := os.Open(file)
	if err != nil {
		return nil, gl.Errorf("erro ao abrir %s: %v", file, err)
	}
	defer f.Close()
	var c Control
	dec := json.NewDecoder(f)
	if err := dec.Decode(&c); err != nil {
		return nil, gl.Errorf("erro ao decodificar %s: %v", file, err)
	}
	c.GlobalRef = &kbx.GlobalRef{Name: moduleName}
	return &c, nil
}

// SaveControl salva o controle do módulo em arquivo separado.
func (c *Control) SaveControl(dir string) error {
	if c.GlobalRef.Name == "" {
		return gl.Errorf("GlobalRef.Name não pode ser vazio para salvar o controle")
	}
	file := filepath.Join(dir, fmt.Sprintf("control_%s.json", c.GlobalRef.Name))
	f, err := os.Create(file)
	if err != nil {
		return gl.Errorf("erro ao criar %s: %v", file, err)
	}
	defer f.Close()
	enc := json.NewEncoder(f)
	enc.SetIndent("", "  ")
	// Reference não é exportado
	return enc.Encode(c)
}

/// ctl/secflags.go ///
package ctl

import (
	"fmt"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"testing"
)

/* ========= FLAGS ========= */

type SecFlag uint32

const (
	SecNone         SecFlag = 0
	SecAuth         SecFlag = 1 << iota // autenticação/autorização
	SecSanitize                         // sanitize em params/headers
	SecSanitizeBody                     // sanitize no body
)

func (f SecFlag) Has(mask SecFlag) bool { return f&mask == mask }
func (f SecFlag) Any(mask SecFlag) bool { return f&mask != 0 }
func (f SecFlag) With(mask SecFlag) SecFlag {
	return f | mask
}
func (f SecFlag) Without(mask SecFlag) SecFlag {
	return f &^ mask
}

// ordem determinística para log/telemetria
var secOrder = []struct {
	name string
	flag SecFlag
}{
	{"auth", SecAuth},
	{"sanitize", SecSanitize},
	{"sanitize_body", SecSanitizeBody},
}

func (f SecFlag) String() string {
	if f == SecNone {
		return "none"
	}
	var parts []string
	for _, it := range secOrder {
		if f.Has(it.flag) {
			parts = append(parts, it.name)
		}
	}
	if len(parts) == 0 {
		return fmt.Sprintf("unknown(0x%X)", uint32(f))
	}
	return strings.Join(parts, "|")
}

/* ======== REGISTRADOR ATÔMICO ======== */

type FlagReg32A[T ~uint32] struct{ v atomic.Uint32 }

// Set  CAS OR (não usa Add; evita somas indevidas quando máscara tem múltiplos bits)
func (r *FlagReg32A[T]) Set(mask T) {
	for {
		old := r.v.Load()
		newV := old | uint32(mask)
		if r.v.CompareAndSwap(old, newV) {
			return
		}
	}
}

// Clear CAS AND NOT
func (r *FlagReg32A[T]) Clear(mask T) {
	for {
		old := r.v.Load()
		newV := old &^ uint32(mask)
		if r.v.CompareAndSwap(old, newV) {
			return
		}
	}
}

// Load current value
func (r *FlagReg32A[T]) Load() T { return T(r.v.Load()) }

// SetIf CAS OR se todos os bits de mustHave estiverem setados
func (r *FlagReg32A[T]) SetIf(mask, mustHave T) bool {
	for {
		old := r.v.Load()
		if (old & uint32(mustHave)) != uint32(mustHave) {
			return false
		}
		newV := old | uint32(mask)
		if r.v.CompareAndSwap(old, newV) {
			return true
		}
	}
}

// ======== MAP LEGADO -> FLAGS ========

// FromLegacyMap converte mapa legado (ex: de config JSON) para flags
func FromLegacyMap(m map[string]bool) SecFlag {
	if m == nil {
		return SecNone
	}
	var f SecFlag
	if m["auth"] {
		f |= SecAuth
	}
	if m["sanitize"] {
		f |= SecSanitize
	}
	if m["sanitize_body"] || m["validateAndSanitizeBody"] {
		f |= SecSanitizeBody
	}
	// compat antiga
	if m["validateAndSanitize"] {
		f |= SecSanitize
	}
	return f
}

/* ======== JOB STATES (bitmask) ======== */

type JobFlagC uint32

const (
	JobNone     JobFlagC = 0
	JobRunningC JobFlagC = 1 << iota
	JobRetryingC
	JobCompletedC
	JobFailedC
	JobTimedOutC
)

func (f JobFlagC) Has(mask JobFlagC) bool { return f&mask == mask }

type JobStateS struct{ reg FlagReg32[uint32] }

func (s *JobStateS) Load() JobFlagC { return JobFlagC(s.reg.Load()) }

func (s *JobStateS) Start() {
	s.reg.Clear(uint32(JobCompletedC | JobFailedC | JobTimedOutC))
	s.reg.Set(uint32(JobRunningC))
}

func (s *JobStateS) Retry() {
	// só marca retry se estava running
	_ = s.reg.SetIf(uint32(JobRetryingC), uint32(JobRunningC))
}

func (s *JobStateS) Complete() {
	// terminal limpa outros
	s.reg.Clear(uint32(JobRunningC | JobRetryingC | JobFailedC | JobTimedOutC))
	s.reg.Set(uint32(JobCompletedC))
}

func (s *JobStateS) Fail() {
	s.reg.Clear(uint32(JobRunningC | JobRetryingC | JobCompletedC | JobTimedOutC))
	s.reg.Set(uint32(JobFailedC))
}

func (s *JobStateS) Timeout() {
	s.reg.Clear(uint32(JobRunningC | JobRetryingC | JobCompletedC | JobFailedC))
	s.reg.Set(uint32(JobTimedOutC))
}

// String returns a string representation of the JobFlagC flags that are set.
// The output is a sorted, pipe-separated list of flag names (e.g., "completed|running").
// If no flags are set, it returns "none".
func (f JobFlagC) String() string {
	order := []struct {
		n string
		b JobFlagC
	}{
		{"running", JobRunningC},
		{"retrying", JobRetryingC},
		{"completed", JobCompletedC},
		{"failed", JobFailedC},
		{"timeout", JobTimedOutC},
	}
	var on []string
	for _, it := range order {
		if f.Has(it.b) {
			on = append(on, it.n)
		}
	}
	if len(on) == 0 {
		return "none"
	}
	sort.Strings(on)
	return strings.Join(on, "|")
}

func TestFlagReg32SetAndClear(t *testing.T) {
	var r FlagReg32[uint32]
	r.Set(uint32(SecAuth | SecSanitize))
	if got := SecFlag(r.Load()); !got.Has(SecAuth | SecSanitize) {
		t.Fatalf("expected flags set, got %v", got)
	}
	r.Clear(uint32(SecSanitize))
	if got := SecFlag(r.Load()); got.Has(SecSanitize) {
		t.Fatalf("sanitize should be cleared, got %v", got)
	}
}

func TestFlagReg32Concurrent(t *testing.T) {
	var r FlagReg32[uint32]
	wg := sync.WaitGroup{}
	N := 1000
	wg.Add(N)
	for i := 0; i < N; i++ {
		go func(i int) {
			defer wg.Done()
			if i%2 == 0 {
				r.Set(uint32(SecAuth))
			} else {
				r.Set(uint32(SecSanitize))
			}
		}(i)
	}
	wg.Wait()
	got := SecFlag(r.Load())
	if !got.Has(SecAuth) || !got.Has(SecSanitize) {
		t.Fatalf("expected both bits set, got %v", got)
	}
}

func TestJobStateTransitions(t *testing.T) {
	var s JobState
	s.Start()

	JobRunning := JobFlag(1 << 0)
	JobRetrying := JobFlag(1 << 1)
	JobCompleted := JobFlag(1 << 2)
	JobFailed := JobFlag(1 << 3)
	JobTimedOut := JobFlag(1 << 4)

	if st := s.Load(); !st.Has(JobRunning) {
		t.Fatalf("start → running, got %v", st)
	}
	s.Retry()
	if st := s.Load(); !st.Has(JobRetrying) {
		t.Fatalf("retry flag missing, got %v", st)
	}
	s.Complete()
	if st := s.Load(); !st.Has(JobCompleted) || st.Has(JobRunning|JobRetrying) {
		t.Fatalf("complete should be terminal only, got %v", st)
	}
	s.Start()
	s.Fail()
	if st := s.Load(); !st.Has(JobFailed) || st.Has(JobRunning) {
		t.Fatalf("failed should be terminal only, got %v", st)
	}
	s.Timeout()
	if st := s.Load(); !st.Has(JobTimedOut) || st.Has(JobRunning) {
		t.Fatalf("timeout should be terminal only, got %v", st)
	}
}

/// ctl/state.go ///
// Package ctl provides abstractions for managing job states and security flags.
package ctl

import (
	"errors"
	"sync/atomic"
)

// Example: Job state flags (combináveis) -------------------------------------

type JobFlag uint32

const (
	JobPendingA JobFlag = 1 << iota
	JobRunningA
	JobCancelRequestedA
	JobRetryingA
	JobCompletedA
	JobFailedA
	JobTimedOutA
)

const (
	terminalMask JobFlag = JobCompletedA | JobFailedA | JobTimedOutA
)

var (
	ErrTerminal = errors.New("job is in a terminal state")
)

func (j JobFlag) Has(flag JobFlag) bool {
	return j&flag != 0
}

type FlagReg32[T ~uint32] struct{ v atomic.Uint32 }

func (r *FlagReg32[T]) Load() T { return T(r.v.Load()) }
func (r *FlagReg32[T]) Store(val T) {
	r.v.Store(uint32(val))
}
func (r *FlagReg32[T]) Set(mask T) { r.v.Add(uint32(mask)) }
func (r *FlagReg32[T]) Clear(mask T) {
	for {
		old := r.v.Load()
		if r.v.CompareAndSwap(old, old&^uint32(mask)) {
			return
		}
	}
}
func (r *FlagReg32[T]) SetIf(clearMask, setMask T) bool {
	for {
		old := r.v.Load()
		if old&uint32(clearMask) != 0 {
			return false
		}
		newV := (old &^ uint32(clearMask)) | uint32(setMask)
		if r.v.CompareAndSwap(old, newV) {
			return true
		}
	}
}
func (r *FlagReg32[T]) Any(mask T) bool { return r.v.Load()&uint32(mask) != 0 }
func (r *FlagReg32[T]) All(mask T) bool { return r.v.Load()&uint32(mask) == uint32(mask) }

type JobState struct{ r FlagReg32[JobFlag] }

func (s *JobState) Load() JobFlag { return s.r.Load() }

// Start only from Pending; sets Running.
func (s *JobState) Start() error {
	ok := s.r.SetIf(terminalMask|JobRunningA|JobCompletedA|JobFailedA|JobTimedOutA, JobRunningA)
	if !ok {
		return ErrTerminal
	}
	return nil
}

// RequestCancel sets the CancelRequested flag.
func (s *JobState) RequestCancel() { s.r.Set(JobCancelRequestedA) }

// Retry sets the job state to Retrying if not in a terminal state.
func (s *JobState) Retry() error {
	// can retry if not terminal; set Retrying and clear Running
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobRetryingA) &^ JobRunningA
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// Complete sets the job state to Completed.
func (s *JobState) Complete() error {
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobCompletedA) &^ (JobRunningA | JobRetryingA | JobCancelRequestedA)
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// Fail sets the job state to Failed.
func (s *JobState) Fail() error {
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobFailedA) &^ (JobRunningA | JobRetryingA)
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// Timeout sets the job state to TimedOut.
func (s *JobState) Timeout() error {
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobTimedOutA) &^ (JobRunningA | JobRetryingA)
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// IsTerminal returns true if the job is in a terminal state.
func (s *JobState) IsTerminal() bool { return s.r.Any(terminalMask) }

/// ctl/types.go ///
package ctl

type IPC struct {
	Type   string `json:"type"`
	Socket string `json:"socket"`
	Mode   string `json:"mode,omitempty"`
}

type Bitreg struct {
	BrfPath string `json:"brf_path"`
	NSBits  int    `json:"ns_bits"`
	Policy  string `json:"policy,omitempty"`

	// CapMask is a hexadecimal string representing the capability mask.
	CapMask string `json:"cap_mask,omitempty"`

	// StateHex is a hexadecimal string representing the state.
	StateHex string `json:"state_hex,omitempty"`
}

type KV struct {
	DeclareHashes []KeyHash `json:"declare_hashes,omitempty"`
	Values        []KVValue `json:"values,omitempty"`
	Encoding      string    `json:"encoding,omitempty"`
}

type KeyHash struct {
	KeyHash string `json:"key_hash"`
}

type KVValue struct {
	KeyHash string `json:"key_hash"`
	U64Hex  string `json:"u64_hex,omitempty"`
}

/// descriptors/control.json ///
{
  "control": {
    "schema_version": 1,
    "module": {
      "name": "Kubex - Grompt",
      "application": "grompt",
      "module_id": "0x7a12c3f1"
    },
    "ipc": {
      "type": "unix",
      "socket": "/run/kbx/grompt.sock",
      "mode": "0600"
    },
    "bitreg": {
      "brf_path": "/var/run/kbx/registry.brf",
      "ns_bits": 1024,
      "policy": "shared",
      "cap_mask": "0x0000000000000000",
      "state_hex": "0x000000000000000b"
    },
    "kv": {
      "declare_hashes": [
        {
          "key_hash": "0x8f12ab34"
        },
        {
          "key_hash": "0x91cc77fe"
        }
      ],
      "values": [
        {
          "key_hash": "0x8f12ab34",
          "u64_hex": "0x0abc00001f90"
        },
        {
          "key_hash": "0x91cc77fe",
          "u64_hex": "0x0abc00001f40"
        }
      ],
      "encoding": "u64_port_claim"
    },
    "seq": 17,
    "epoch_ns": 1724370000000000000
  }
}

/// descriptors/descriptors.go ///
// Package descriptors provides various descriptor types used across the application.
package descriptors

import "embed"

//go:embed all:*.json
var manifestJSONFiles embed.FS

func GetManifestJSONFiles() embed.FS { return manifestJSONFiles }

/// descriptors/manifest.json ///
{
  "name": "Canalize - BE",
  "application": "canalize_be",
  "version": "0.0.1",
  "private": true,
  "published": false,
  "aliases": [
    "canalize_be"
  ],
  "repository": "https://github.com/canalize-prm/canalize_be",
  "homepage": "https://github.com/canalize-prm/canalize_be",
  "description": "Canalize PRM Backend Project",
  "go_version": "1.25.5",
  "main": "cmd/main.go",
  "bin": "canalize_be",
  "author": "Rafael Mori <faelmori@gmail.com>",
  "organization": "canalize-prm",
  "license": "Proprietary",
  "keywords": [
    "prm",
    "backend",
    "golang",
    "canalize-prm",
    "kubex",
    "control",
    "command-line",
    "tool",
    "management"
  ],
  "platforms": [
    "linux/amd64",
    "linux/arm64",
    "darwin/amd64",
    "darwin/arm64",
    "windows/amd64"
  ],
  "dependencies": [
    "tar",
    "gzip",
    "curl",
    "git",
    "zip",
    "unzip",
    "jq",
    "upx"
  ],
  "healthcheck_type": "http",
  "healthcheck_url": "http://localhost:4000/health",
  "healthcheck_cmd": "systemctl --user is-active canalize-be.service"
}

/// interfaces.go ///
package info

import (
	"github.com/google/uuid"
)

type Manifest interface {
	GetName() string
	GetVersion() string
	GetAliases() []string
	GetRepository() string
	GetHomepage() string
	GetDescription() string
	GetMain() string
	GetBin() string
	GetAuthor() string
	GetLicense() string
	GetKeywords() []string
	GetPlatforms() []string
	IsPrivate() bool
}

type KubexModuleCLI interface {
	ID() uuid.UUID
	Module() string
	Alias() string
	ShortDescription() string
	LongDescription() string
	Usage() string
	Examples() []string
	Active() bool
	Execute() error
}

/// module_cli.go ///
// Package module provides internal types and functions for the KubexModuleCLIImpl application.
package info

import (
	"github.com/fatih/color"
	"github.com/google/uuid"
	"github.com/kubex-ecosystem/kbx"
	gl "github.com/kubex-ecosystem/logz"
	"github.com/spf13/cobra"

	"os"
	"strings"
)

type KubexModuleCLIImpl struct {
	*kbx.GlobalRef
	*kbx.ParamsImpl

	*cobra.Command

	Enable      bool
	PrintBanner bool
	Banners     []string

	alias       string
	shortDesc   string
	longDesc    string
	usage       string
	annotations map[string]string
	examples    []string

	parentCmdName string
}

func RunKbx() KubexModuleCLI {
	var printBannerV = os.Getenv("GROMPT_PRINT_BANNER")
	if printBannerV == "" {
		printBannerV = "true"
	}

	return &KubexModuleCLIImpl{
		PrintBanner: strings.ToLower(printBannerV) == "true",
	}
}

func (m *KubexModuleCLIImpl) ID() uuid.UUID            { return m.GlobalRef.ID }
func (m *KubexModuleCLIImpl) Module() string           { return m.GlobalRef.Name }
func (m *KubexModuleCLIImpl) Alias() string            { return m.alias }
func (m *KubexModuleCLIImpl) ShortDescription() string { return m.shortDesc }
func (m *KubexModuleCLIImpl) LongDescription() string  { return m.longDesc }
func (m *KubexModuleCLIImpl) Usage() string            { return m.usage }
func (m *KubexModuleCLIImpl) Examples() []string       { return m.examples }
func (m *KubexModuleCLIImpl) Active() bool             { return m.Enable }
func (m *KubexModuleCLIImpl) Execute() error           { return m.command().Execute() }

func (m *KubexModuleCLIImpl) command() *cobra.Command {
	gl.Debugf("Starting %s CLI...", m.Module())

	// Build the root command
	err := m.buildRootCommand()
	if err != nil {
		return nil
	}

	// Add more commands as needed
	m.AddCommand(CliCommand())

	// Set usage definitions for the command and its subcommands
	m.setUsageDefinition(m.Command)
	for _, c := range m.Command.Commands() {
		m.setUsageDefinition(c)
		if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
			if c.Short == "" {
				c.Short = c.Annotations["description"]
			}
		}
	}

	return m.Command
}

func (m *KubexModuleCLIImpl) SetParentCmdName(parentCmdName string) {
	m.parentCmdName = parentCmdName
}

func (m *KubexModuleCLIImpl) concatenateExamples() string {
	examples := ""
	rtCmd := m.parentCmdName
	if rtCmd != "" {
		rtCmd = rtCmd + " "
	}
	for _, example := range m.Examples() {
		examples += rtCmd + example + "\n  "
	}
	return examples
}

func (m *KubexModuleCLIImpl) buildRootCommand() error {
	if m.Command == nil {
		m.Command = &cobra.Command{
			Use:   m.Module(),
			Short: m.ShortDescription(),
			Long:  m.LongDescription(),
			Run: func(cmd *cobra.Command, args []string) {
				// Default action when no subcommand is provided
				cmd.Help()
			},
		}
	} else {
		m.Command.Use = m.Module()
		m.Command.Short = m.ShortDescription()
		m.Command.Long = m.LongDescription()
		m.Command.Example = m.concatenateExamples()
		m.Command.Aliases = []string{m.Alias()}
	}
	return nil
}

func (m *KubexModuleCLIImpl) colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}
func (m *KubexModuleCLIImpl) colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}
func (m *KubexModuleCLIImpl) colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}
func (m *KubexModuleCLIImpl) colorRed(s string) string { return color.New(color.FgRed).SprintFunc()(s) }
func (m *KubexModuleCLIImpl) colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}

func (m *KubexModuleCLIImpl) hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}
func (m *KubexModuleCLIImpl) hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}
func (m *KubexModuleCLIImpl) setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", m.colorYellow)
	cobra.AddTemplateFunc("colorGreen", m.colorGreen)
	cobra.AddTemplateFunc("colorRed", m.colorRed)
	cobra.AddTemplateFunc("colorBlue", m.colorBlue)
	cobra.AddTemplateFunc("colorHelp", m.colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", m.hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", m.hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(m.cliTemplate())
}
func (m *KubexModuleCLIImpl) cliTemplate() string {
	var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`
	return cliUsageTemplate
}

/// semantic.go ///
// Package version provides functionality to manage and check the version of the Kubex Horizon CLI tool.
// It includes methods to retrieve the current version, check for the latest version,
package info

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	gl "github.com/kubex-ecosystem/logz"
	"github.com/spf13/cobra"
)

var (
	info Manifest
	vrs  Service
	err  error
)

func init() {
	if info == nil {
		info, err = GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
}

type Service interface {
	// GetLatestVersion retrieves the latest version from the Git repository.
	GetLatestVersion() (string, error)
	// GetCurrentVersion returns the current version of the service.
	GetCurrentVersion() string
	// IsLatestVersion checks if the current version is the latest version.
	IsLatestVersion() (bool, error)
	// GetName returns the name of the service.
	GetName() string
	// GetVersion returns the current version of the service.
	GetVersion() string
	// GetRepository returns the Git repository URL of the service.
	GetRepository() string
	// setLastCheckedAt sets the last checked time for the version.
	setLastCheckedAt(time.Time)
	// updateLatestVersion updates the latest version from the Git repository.
	updateLatestVersion() error
}
type ServiceImpl struct {
	Manifest
	gitModelURL    string
	latestVersion  string
	lastCheckedAt  time.Time
	currentVersion string
}

func init() {
	if info == nil {
		var err error
		info, err = GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
	if vrs == nil {
		vrs = NewVersionService()
	}
}

func getLatestTag(repoURL string) (string, error) {
	defer func() {
		if rec := recover(); rec != nil {
			gl.Log("error", "Recovered from panic in getLatestTag: %v", rec)
			err = gl.Errorf("panic occurred while fetching latest tag: %v", rec)
		}
	}()

	defer func() {
		if vrs == nil {
			vrs = NewVersionService()
		}
		vrs.setLastCheckedAt(time.Now())
	}()

	if info == nil {
		var err error
		info, err = GetManifest()
		if err != nil {
			return "", gl.Errorf("failed to get manifest: %v", err)
		}
	}
	if info.IsPrivate() {
		return "", gl.Errorf("cannot fetch latest tag for private repositories")
	}

	if repoURL == "" {
		repoURL = info.GetRepository()
		if repoURL == "" {
			return "", gl.Errorf("repository URL is not set")
		}
	}

	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", gl.Errorf("failed to fetch tags: %s", resp.Status)
	}
	type Tag struct {
		Name string `json:"name"`
	}

	// Decode the JSON response into a slice of Tag structs
	// This assumes the API returns a JSON array of tags.
	// Adjust the decoding logic based on the actual API response structure.
	if resp.Header.Get("Content-Type") != "application/json" {
		return "", gl.Errorf("expected application/json, got %s", resp.Header.Get("Content-Type"))
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", gl.Errorf("no tags found")
	}
	return tags[0].Name, nil
}
func (v *ServiceImpl) updateLatestVersion() error {
	if info.IsPrivate() {
		return gl.Errorf("cannot fetch latest version for private repositories")
	}
	repoURL := strings.TrimSuffix(v.gitModelURL, ".git")
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	compare := 0
	for i := 0; i < len(v1) && i < len(v2); i++ {
		if v1[i] < v2[i] {
			compare = -1
			break
		}
		if v1[i] > v2[i] {
			compare = 1
			break
		}
	}
	return compare, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	if versionToParse == "" {
		return nil
	}
	if strings.Contains(versionToParse, "-") {
		versionToParse = strings.Split(versionToParse, "-")[0]
	}
	if strings.Contains(versionToParse, "v") {
		versionToParse = strings.TrimPrefix(versionToParse, "v")
	}
	parts := strings.Split(versionToParse, ".")
	parsedVersion := make([]int, len(parts))
	for i, part := range parts {
		if num, err := strconv.Atoi(part); err != nil {
			return nil
		} else {
			parsedVersion[i] = num
		}
	}
	return parsedVersion
}
func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if info.IsPrivate() {
		return false, gl.Errorf("cannot check version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	currentVersionParts := v.parseVersion(v.currentVersion)
	latestVersionParts := v.parseVersion(v.latestVersion)

	if len(currentVersionParts) == 0 || len(latestVersionParts) == 0 {
		return false, gl.Errorf("invalid version format")
	}

	if len(currentVersionParts) != len(latestVersionParts) {
		return false, gl.Errorf("version parts length mismatch")
	}

	return v.versionAtMost(currentVersionParts, latestVersionParts)
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if info.IsPrivate() {
		return "", gl.Errorf("cannot fetch latest version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}
	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string {
	if v.currentVersion == "" {
		v.currentVersion = info.GetVersion()
	}
	return v.currentVersion
}
func (v *ServiceImpl) GetName() string {
	if info == nil {
		return "Unknown Service"
	}
	return info.GetName()
}
func (v *ServiceImpl) GetVersion() string {
	if info == nil {
		return "Unknown version"
	}
	return info.GetVersion()
}
func (v *ServiceImpl) GetRepository() string {
	if info == nil {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func (v *ServiceImpl) setLastCheckedAt(t time.Time) {
	v.lastCheckedAt = t
	gl.Log("debug", "Last checked at: "+t.Format(time.RFC3339))
}

func NewVersionService() Service {
	return &ServiceImpl{
		Manifest:       info,
		gitModelURL:    info.GetRepository(),
		currentVersion: info.GetVersion(),
		latestVersion:  "",
	}
}

var (
	versionCmd   *cobra.Command
	subLatestCmd *cobra.Command
	subCmdCheck  *cobra.Command
	updCmd       *cobra.Command
	getCmd       *cobra.Command
	restartCmd   *cobra.Command
)

func init() {
	if versionCmd == nil {
		versionCmd = &cobra.Command{
			Use:   "version",
			Short: "Print the version number of " + info.GetName(),
			Long:  "Print the version number of " + info.GetName() + " and other related information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("warn", "The information shown may not be accurate for private repositories.")
					gl.Log("info", "Current version: "+GetVersion())
					gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
					return
				}
				GetVersionInfo()
			},
		}
	}
	if subLatestCmd == nil {
		subLatestCmd = &cobra.Command{
			Use:   "latest",
			Short: "Print the latest version number of " + info.GetName(),
			Long:  "Print the latest version number of " + info.GetName() + " from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot fetch latest version for private repositories.")
					return
				}
				GetLatestVersionInfo()
			},
		}
	}
	if subCmdCheck == nil {
		subCmdCheck = &cobra.Command{
			Use:   "check",
			Short: "Check if the current version is the latest version of " + info.GetName(),
			Long:  "Check if the current version is the latest version of " + info.GetName() + " and print the version information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot check version for private repositories.")
					return
				}
				GetVersionInfoWithLatestAndCheck()
			},
		}
	}
	if updCmd == nil {
		updCmd = &cobra.Command{
			Use:   "update",
			Short: "Update the version information of " + info.GetName(),
			Long:  "Update the version information of " + info.GetName() + " by fetching the latest version from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot update version for private repositories.")
					return
				}
				if err := vrs.updateLatestVersion(); err != nil {
					gl.Log("error", "Failed to update version: "+err.Error())
				} else {
					latestVersion, err := vrs.GetLatestVersion()
					if err != nil {
						gl.Log("error", "Failed to get latest version: "+err.Error())
					} else {
						gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
						gl.Log("info", "Latest version: "+latestVersion)
					}
					vrs.setLastCheckedAt(time.Now())
				}
			},
		}
	}
	if getCmd == nil {
		getCmd = &cobra.Command{
			Use:   "get",
			Short: "Get the current version of " + info.GetName(),
			Long:  "Get the current version of " + info.GetName() + " from the manifest.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
			},
		}
	}
	if restartCmd == nil {
		restartCmd = &cobra.Command{
			Use:   "restart",
			Short: "Restart the " + info.GetName() + " service",
			Long:  "Restart the " + info.GetName() + " service to apply any changes made.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Restarting the service...")
				// Logic to restart the service can be added here
				gl.Log("success", "Service restarted successfully")
			},
		}
	}

}
func GetVersion() string {
	if info == nil {
		_, err := GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
			return "Unknown version"
		}
	}
	return info.GetVersion()
}
func GetGitRepositoryModelURL() string {
	if info.GetRepository() == "" {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func GetVersionInfo() string {
	gl.Log("info", "Version: "+GetVersion())
	gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitRepositoryModelURL())
}
func GetLatestVersionFromGit() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}

	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitURLWithoutGit := strings.TrimSuffix(GetGitRepositoryModelURL(), ".git")
	if gitURLWithoutGit == "" {
		gl.Log("error", "No repository URL set in the manifest.")
		return "No repository URL set in the manifest."
	}

	response, err := netClient.Get(gitURLWithoutGit + "/releases/latest")
	if err != nil {
		gl.Log("error", "Error fetching latest version: "+err.Error())
		gl.Log("error", gitURLWithoutGit+"/releases/latest")
		return err.Error()
	}

	if response.StatusCode != 200 {
		gl.Log("error", "Error fetching latest version: "+response.Status)
		gl.Log("error", "Url: "+gitURLWithoutGit+"/releases/latest")
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("Error: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}
func GetLatestVersionInfo() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}
	gl.Log("info", "Latest version: "+GetLatestVersionFromGit())
	return "Latest version: " + GetLatestVersionFromGit()
}
func GetVersionInfoWithLatestAndCheck() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot check version for private repositories.")
		return "Cannot check version for private repositories."
	}
	if GetVersion() == GetLatestVersionFromGit() {
		gl.Log("info", "You are using the latest version.")
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		gl.Log("warn", "You are using an outdated version.")
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}
func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	versionCmd.AddCommand(updCmd)
	versionCmd.AddCommand(getCmd)
	versionCmd.AddCommand(restartCmd)
	return versionCmd
}
